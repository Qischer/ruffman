
logo
std
1.80.1
(3f5fd8dd4 2024-08-06)
Primitive Types

    array
    bool
    char
    f128
    f16
    f32
    f64
    fn
    i128
    i16
    i32
    i64
    i8
    isize
    never
    pointer
    reference
    slice
    str
    tuple
    u128
    u16
    u32
    u64
    u8
    unit
    usize

Modules

    alloc
    any
    arch
    array
    ascii
    assert_matches
    async_iter
    backtrace
    borrow
    boxed
    cell
    char
    clone
    cmp
    collections
    convert
    default
    env
    error
    f128
    f16
    f32
    f64
    ffi
    fmt
    fs
    future
    hash
    hint
    i128
    i16
    i32
    i64
    i8
    intrinsics
    io
    isize
    iter
    marker
    mem
    net
    num
    ops
    option
    os
    panic
    pat
    path
    pin
    prelude
    primitive
    process
    ptr
    rc
    result
    simd
    slice
    str
    string
    sync
    task
    thread
    time
    u128
    u16
    u32
    u64
    u8
    usize
    vec

Macros

    assert
    assert_eq
    assert_ne
    cfg
    cfg_match
    column
    compile_error
    concat
    concat_bytes
    concat_idents
    const_format_args
    dbg
    debug_assert
    debug_assert_eq
    debug_assert_ne
    env
    eprint
    eprintln
    file
    format
    format_args
    format_args_nl
    include
    include_bytes
    include_str
    is_x86_feature_detected
    line
    log_syntax
    matches
    module_path
    option_env
    panic
    print
    println
    stringify
    thread_local
    todo
    trace_macros
    try
    unimplemented
    unreachable
    vec
    write
    writeln

Keywords

    SelfTy
    as
    async
    await
    break
    const
    continue
    crate
    dyn
    else
    enum
    extern
    false
    fn
    for
    if
    impl
    in
    let
    loop
    match
    mod
    move
    mut
    pub
    ref
    return
    self
    static
    struct
    super
    trait
    true
    type
    union
    unsafe
    use
    where
    while

?
Settings
Macro std::dbg
1.32.0 · source ·

macro_rules! dbg {
    () => { ... };
    ($val:expr $(,)?) => { ... };
    ($($val:expr),+ $(,)?) => { ... };
}

Prints and returns the value of a given expression for quick and dirty debugging.

An example:

let a = 2;
let b = dbg!(a * 2) + 1;
//      ^-- prints: [src/main.rs:2] a * 2 = 4
assert_eq!(b, 5);

Run

The macro works by using the Debug implementation of the type of the given expression to print the value to stderr along with the source location of the macro invocation as well as the source code of the expression.

Invoking the macro on an expression moves and takes ownership of it before returning the evaluated expression unchanged. If the type of the expression does not implement Copy and you don’t want to give up ownership, you can instead borrow with dbg!(&expr) for some expression expr.

The dbg! macro works exactly the same in release builds. This is useful when debugging issues that only occur in release builds or when debugging in release mode is significantly faster.

Note that the macro is intended as a debugging tool and therefore you should avoid having uses of it in version control for long periods (other than in tests and similar). Debug output from production code is better done with other facilities such as the debug! macro from the log crate.
Stability

The exact output printed by this macro should not be relied upon and is subject to future changes.
Panics

Panics if writing to io::stderr fails.
Further examples

With a method call:

fn foo(n: usize) {
    if let Some(_) = dbg!(n.checked_sub(4)) {
        // ...
    }
}

foo(3)

This prints to stderr:

[src/main.rs:4] n.checked_sub(4) = None

Naive factorial implementation:

fn factorial(n: u32) -> u32 {
    if dbg!(n <= 1) {
        dbg!(1)
    } else {
        dbg!(n * factorial(n - 1))
    }
}

dbg!(factorial(4));

This prints to stderr:

[src/main.rs:3] n <= 1 = false
[src/main.rs:3] n <= 1 = false
[src/main.rs:3] n <= 1 = false
[src/main.rs:3] n <= 1 = true
[src/main.rs:4] 1 = 1
[src/main.rs:5] n * factorial(n - 1) = 2
[src/main.rs:5] n * factorial(n - 1) = 6
[src/main.rs:5] n * factorial(n - 1) = 24
[src/main.rs:11] factorial(4) = 24

The dbg!(..) macro moves the input:
ⓘ

/// A wrapper around `usize` which importantly is not Copyable.
#[derive(Debug)]
struct NoCopy(usize);

let a = NoCopy(42);
let _ = dbg!(a); // <-- `a` is moved here.
let _ = dbg!(a); // <-- `a` is moved again; error!

You can also use dbg!() without a value to just print the file and line whenever it’s reached.

Finally, if you want to dbg!(..) multiple values, it will treat them as a tuple (and return it, too):

assert_eq!(dbg!(1usize, 2u32), (1, 2));

However, a single argument with a trailing comma will still not be treated as a tuple, following the convention of ignoring trailing commas in macro invocations. You can use a 1-tuple directly if you need one:

assert_eq!(1, dbg!(1u32,)); // trailing comma ignored
assert_eq!((1,), dbg!((1u32,))); // 1-tuple

